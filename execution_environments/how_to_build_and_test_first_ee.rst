.. _how_to_build_and_test_first_ee:

******************************************************
How To Build and Test Your First Execution Environment
******************************************************

* We assume that you installed all :ref:`required packages<how_to_prepare_environment>`.
* For general information about Execution Environments, see the :ref:`Ansible Execution Environments Overview<ee_overview>` document.


.. _build_first_ee:

Building your first EE
======================

We are going to build an EE containing, in addition to standard packages like ansible-core and Python,
an Ansible collection (``community.postgresql``) and its dependency (the ``psycopg2`` Python connector).

The collection and the dependency can be replaced with any other package you need.

1. Create and go to a project directory for your new EE:

.. code-block:: bash

  $ mkdir postgresql_ee && cd postgresql_ee

2. Create the ``requirements.yml`` file which will specify collections you want to include in your EE.
Tell it that you want the ``community.postgresql`` collection:

.. code-block:: yaml

  ---
  collections:
    - name: community.postgresql

3. Create the ``requirements.txt`` file which will list Python dependencies you want to include.
In this how-to, you want the ``psycopg2-binary`` package:

.. code-block:: bash

  psycopg2-binary

4. Create the ``execution-environment.yml`` definition file that specifies which content you want to include.
List the files you created at previous steps:

.. code-block:: yaml

  ---
  version: 1

  dependencies:
    galaxy: requirements.yml
    python: requirements.txt

5. Create the ``demo`` build context directory:

.. code-block:: bash

  $ mkdir demo

Besides container artifacts, it will contain a ``Containerfile`` generated by ``ansible-builder``,
our inventories and playbooks we will add later to test the EE with ``ansible-runner``.

6. Build the EE container image called ``postgresql_ee`` using the ``demo`` directory as a build context (if you use docker, add the ``--container-runtime docker`` argument to the command):

.. code-block:: bash

  $ ansible-builder build --tag postgresql_ee --context demo

7. You now can see the container image in the list of images. Assuming you use podman:

.. code-block:: bash

  $ podman image list

  localhost/postgresql_ee          latest      2e866777269b  6 minutes ago  1.11 GB

8. Inspect the ``Containerfile`` file (``Dockerfile`` if you use docker) in the ``demo`` directory to see the EE container image configuration.

The created image represents an :ref:`Ansible control node<terminology>` which now contains:

* Python
* ansible-core
* the community.postgresql collection
* the psycopg2-binary Python package

See the :ref:`Running your EE in command line<run_firt_ee>` section to learn how to test the EE you have just created.

**TBD: Add links referring to overview pages for the files above when created.**

**TBD: Add a link to the builder's overview page when created.**

For more information about Ansible Builder, see the :ref:`Ansible Builder Overview<ADD_LINK_WHEN_WRITTEN>` document.


.. _run_first_ee:

Running your EE in command line
===============================

Here, we will test the EE you created in the :ref:`Building your first EE<build_first_ee>` section against the localhost and a remote target.

You are still in the ``postgresql_ee`` directory.

Create two other directories for our inventories and playbooks:

.. code-block:: bash

  $ mkdir demo/inventory demo/project

If you use ``docker``:

* add the ``--process-isolation-executable docker`` argument to the ``ansible-runner`` commands below
* the EE image name used in the commands can differ


Run against localhost
---------------------

1. Create the ``test_localhost.yml`` playbook file in the ``demo/project`` directory with the following content:

.. code-block:: yaml

  ---
  - hosts: localhost
    become: yes
    gather_facts: yes
    tasks:
    - name: Print facts
      ansible.builtin.debug:
        msg: '{{ ansible_facts }}'

2. Run the playbook inside the EE container with ``ansible-runner``:

.. code-block:: bash

  $ ansible-runner run demo --playbook test_localhost.yml --container-image localhost/postgresql_ee --process-isolation

The run will return facts gathered inside the container.


Run against a remote target
---------------------------

1. Create the ``hosts`` file under the ``demo/inventory`` directory containing:

.. code-block:: bash

  [dbservers]
  192.168.0.4  # Replace with IP of your test target machine

2. Create the ``test_remote.yml`` playbook file in the ``demo/project`` directory containing:

.. code-block:: yaml

  ---
  - hosts: dbservers
    become: yes
    gather_facts: yes
    tasks:
    - name: Print facts
      ansible.builtin.debug:
        msg: '{{ ansible_facts }}'

3. Run the playbook inside the EE container with ``ansible-runner``:

.. code-block:: bash

  $ ansible-runner run demo --playbook test_remote.yml --container-image localhost/postgresql_ee --process-isolation --cmdline '--extra-vars "ansible_user=student ansible_password=student ansible_host_key_checking=False ansible_become_password=student"'

This example assumes that you have the ``student`` user using ``student`` as password
and having permissions to run commands as a superuser on your target machine.
The ``--cmdline`` argument might be omitted depending on your actual connection and target system configuration.


More about Ansible Runner
-------------------------

**TBD: Add a link to the runner's EE-specific overview page when created.**

For more information about Ansible Runner, see the :ref:`Ansible Runner EE-specific overview<ADD_LINK_WHEN_WRITTEN>` document.
