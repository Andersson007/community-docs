******************************************************
How To Build and Test Your First Execution Environment
******************************************************

* We assume that you installed all required packages. See the :ref:`How to prepare you environment to build and test EEs<how_to_prepare_environment>` guide for details.
* For general information about Execution Environments, see the :ref:`Ansible Execution Environments Overview<ee_overview>` document.


**TBD: Test the following again on fresh VMs**

**TBD: Test the below with docker**

.. _build_first_ee:

Building your first EE
======================

We are going to build an EE containing, in addition to standard packages like ansible-core and Python,
an Ansible collection (``community.postgresql``) and its dependency (the ``psycopg2`` Python connector).

The collection and the dependency can be replaced with any other package you need.

1. Create and go to a project directory for your new EE:

.. code-block:: bash

  $ mkdir postgresql_ee && cd postgresql_ee

2. Create the ``requirements.yml`` file which will specify collections you want to include in your EE.
Tell it that you want the ``community.postgresql`` collection:

.. code-block:: yaml

  ---
  collections:
    - name: community.postgresql 

3. Create the ``requirements.txt`` file which will list Python dependencies you want to include.
In this how-to, you want the ``psycopg2-binary`` package:

.. code-block:: bash

  psycopg2-binary

4. Create the ``execution-environment.yml`` definition file that specifies which content you want to include.
List the files with you created at previous steps:

.. code-block:: yaml

  ---
  version: 1

  dependencies:
    galaxy: requirements.yml
    python: requirements.txt

5. Create the ``demo`` directory which will be used as a build contex:

.. code-block:: bash

  $ mkdir demo

This directory will be used as a build contex: it will contain a ``Containerfile``
generated by ``ansbible-builder``, our inventories and playbooks you will create later.

This directory will also be passed to ``ansible-runner`` when you test the EE
in the :ref:`Running your EE in command line<run_firt_ee>` section.

6. Build the EE:

.. code-block:: bash

  $ ansible-builder build --tag postgresql_ee --context demo

7. You now can see the container image in the list of images (assuming you use podman):

.. code-block:: bash

  $ podman image list

  localhost/postgresql_ee          latest      2e866777269b  6 minutes ago  1.11 GB

8. Inspect the ``Containerfile`` file (``Dockerfile`` if you use docker) in the ``demo`` directory to see the EE container image configuration.

The created image which can be used as an :ref:`Ansible control node<terminology>` now contains:

* Python
* ansible-core
* the community.postgresql collection
* the psycopg2-binary Python package

See the :ref:`Running your EE in command line<run_firt_ee>` section to learn how to test the EE you have just created.

**TBD: Add links referring to overview pages for the files above when created.**

**TBD: Add a link to the builder's overview page when created.**

For more information about Ansible Builder, see the :ref:`Ansible Builder Overview<ADD_LINK_WHEN_WRITTEN>` document.


.. _run_first_ee:

Running your EE in command line
===============================

Here, we will test the EE you created in the :ref:`Building your first EE<build_first_ee>` section against the localhost and a remote target.

You are still in the ``postgresql_ee`` directory.

Create two other directories for our inventories and Ansible content:

.. code-block:: bash

  $ mkdir demo/inventory demo/project

If you use ``docker``:

* add the ``--process-isolation-executable docker`` argument to the ``ansible-runner`` commands below
* the EE image name used in the commands can differ

Run against the EE itself
-------------------------

1. Create the ``test_localhost.yml`` playbook file in the ``demo/project`` directory with the following content:

.. code-block:: yaml

  ---
  - hosts: localhost
    become: yes
    gather_facts: yes
    tasks:
    - name: Print facts
      ansible.builtin.debug:
        msg: '{{ ansible_facts }}'

2. Run the playbook inside the EE with ``ansible-runner``:

.. code-block:: bash

  $ ansible-runner run demo --playbook test_localhost.yml --container-image localhost/postgresql_ee --process-isolation


Run against a remote target
---------------------------

1. Create the ``hosts`` file under the ``demo/inventory`` directory with the following content:

.. code-block:: bash

  [dbservers]
  192.168.0.4  # Replace with IP of your test target machine

2. Create the ``test_remote.yml`` playbook file in the ``demo/project`` directory with the following content:

.. code-block:: yaml

  ---
  - hosts: dbservers
    become: yes
    gather_facts: yes
    tasks:
    - name: Print facts
      ansible.builtin.debug:
        msg: '{{ ansible_facts }}'

3. Run the playbook inside the EE with ``ansible-runner``:

.. code-block:: bash

  $ ansible-runner run demo --playbook test_remote.yml --container-image localhost/postgresql_ee --process-isolation --limit 192.168.0.4 --cmdline '--extra-vars "ansible_user=student ansible_password=student ansible_host_key_checking=False ansible_become_password=student"'

The ``--limit`` and ``--cmdline`` arguments are optional.

More about Ansible Runner
-------------------------

**TBD: Add a link to the runner's EE-specific overview page when created.**

For more information about Ansible Runner, see the :ref:`Ansible Runner EE-specific overview<ADD_LINK_WHEN_WRITTEN>` document.
