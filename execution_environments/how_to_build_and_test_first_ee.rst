.. _how_to_build_and_test_first_ee:

******************************************************
How To Build and Test Your First Execution Environment
******************************************************

* We assume that you installed all :ref:`required packages<how_to_prepare_environment>`.
* For general information about Execution Environments, see the :ref:`Ansible Execution Environments Overview<ee_overview>` document.


.. _build_first_ee:

Building your first EE
======================

We are going to build an EE containing, in addition to standard packages like ansible-core and Python,
an Ansible collection (``community.postgresql``) and its dependency (the ``psycopg2-binary`` Python connector).

The collection and the dependency can be replaced with any other package you need.

1. Create and go to a project directory for your new EE:

.. code-block:: bash

  $ mkdir postgresql_ee && cd postgresql_ee

2. Create the ``execution-environment.yml`` definition file that specifies which content you want to include.

.. code-block:: yaml

  ---
  version: 3

  dependencies:
    galaxy:
      collections:
      - name: community.postgresql

Notice that we do not specify the ``psycopg2-binary`` Python package as a dependency in the definition file
because ``ansible-buider`` will install it automatically based on  the collection's ``requirements.txt`` file.

.. note::

  If a collection you want to install does not have the ``requirements.txt`` file,
  you need to add Python dependencies specified in the collection's documentation to your the definition file manually.

Read more about the EE definition file format in the `Ansible Builder documentation <https://ansible-builder.readthedocs.io/en/stable/definition/>`_.

3. Build the EE container image called ``postgresql_ee`` (if you use docker, add the ``--container-runtime docker`` argument to the command):

.. code-block:: bash

  $ ansible-builder build --tag postgresql_ee

4. You now can see the container image in the list of images. Assuming you use podman:

.. code-block:: bash

  $ podman image list

  localhost/postgresql_ee          latest      2e866777269b  6 minutes ago  1.11 GB

5. Inspect the ``Containerfile`` file (``Dockerfile`` if you use docker) in the ``context`` directory generated by ``ansible-builder`` to see the EE container image configuration.

The created image represents an :ref:`Ansible control node<terminology>` which now contains:

* Python
* ansible-core
* ansible-runner
* the community.postgresql collection
* the psycopg2-binary Python package

Run ``ansible-navigator``, type ``:images`` in the TUI and choose ``postgresql_ee`` to view detailed information about the image.

See the :ref:`Running your EE in command line<run_firt_ee>` section to learn how to test the EE you have just created.

For more information about Ansible Builder, see its :ref:`official documentation <https://ansible-builder.readthedocs.io/en/stable/>`_.

.. _run_first_ee:

Running your EE in command line
===============================

Here, we will test the EE you created in the :ref:`Building your first EE<build_first_ee>` section against the localhost and a remote target.

You can now create a project directory in your home (or in any other arbitrary) directory.
Change your current working directory to be the project directory:

.. code-block:: yaml

  $ mkdir ~/my_project && cd ~/my_project

You can create a custom ``ansible.cfg`` file there if needed.

Run against localhost
---------------------

We assume you are in the project directory.

1. Create the ``test_localhost.yml`` playbook file with the following content:

.. code-block:: yaml

  ---
  - hosts: localhost
    become: yes
    gather_facts: yes
    tasks:
    - name: Print facts
      ansible.builtin.debug:
        msg: '{{ ansible_facts }}'

2. Run the playbook inside the EE container with ``ansible-navigator``:

.. code-block:: bash

  $ ansible-navigator run test_localhost.yml --execution-environment-image postgresql_ee --mode stdout --pull-policy missing

You may notice the facts being gathered are about the container and not the developer machine. This is because the ansible playbook was run inside the container.

Run against a remote target
---------------------------

1. Being in the project directory, create a directory for inventory files:

.. code-block:: yaml

  $ mkdir inventory

2. Create the ``hosts.yml`` inventory file in the ``inventory`` directory containing:

.. code-block:: yaml

  ---
  all:
    hosts:
      192.168.0.4  # Replace with IP of your test target machine

3. Create the ``test_remote.yml`` playbook file containing:

.. code-block:: yaml

  ---
  - hosts: all
    become: yes
    gather_facts: yes
    tasks:
    - name: Print facts
      ansible.builtin.debug:
        msg: '{{ ansible_facts }}'

4. Run the playbook inside the EE container with ``ansible-navigator``:

.. code-block:: bash

  $ ansible-navigator run test_remote.yml -i inventory --execution-environment-image postgresql_ee:latest --mode stdout --pull-policy missing --enable-prompts -u student -k -K

This example assumes that you have the ``student`` user using ``student`` as password
and having permissions to run commands as a superuser on your target machine.

More about Ansible Navigator
----------------------------

For more information about Ansible Navigator, see its `official documentation<https://ansible-navigator.readthedocs.io/>`_.
